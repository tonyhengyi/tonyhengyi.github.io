### 一些术语
#### 状态
状态可以笼统的解释为问题所在的局面，例如说（用变量所表示的）所在的局面的（最优）答案，或者满足某种性质的方案数。“凑够w的金额”是一种关于w的局面，“从x走到y”是一种关于x，y的局面。如果初学者不知道怎么确定状态，可以考虑套用最为朴素的搜索算法里的状态。
#### 状态转移方程
第一题纸笔问题里面转移方程就是
f(w)=minf(w-ai)+1;
第二题转移方程就是
g(x,y)=max(g(x+1,y),g(x+1,y+1))+a[x][y]
转移方程的目的是为了找到最优解的前继情况。

---
### 纸笔问题2


## 题目背景

你是一个非常有钱的小朋友。

## 题目描述

你有 $n$ 种面额互不相同的纸币，第 $i$ 种纸币的面额为 $a_i$ 并且有无限张，现在你需要支付 $w$ 的金额，求问有多少种方式可以支付面额 $w$，答案对 $10^9+7$ 取模。  
注意在这里，同样的纸币组合如果支付顺序不同，会被视作不同的方式。例如支付 $3$ 元，使用一张面值 $1$ 的纸币和一张面值 $2$ 的纸币会产生两种方式（$1+2$ 和 $2+1$）。

## 输入格式

第一行两个正整数 $n,w$，分别表示纸币的种数和要凑出的金额。  
第二行一行 $n$ 个以空格隔开的正整数 $a_1, a_2, \dots a_n $ 依次表示这 $n$ 种纸币的面额。

## 输出格式

一行一个整数，表示支付方式的数量。

## 样例 #1

### 样例输入 #1

```
6 15
1 5 10 20 50 100
```

### 样例输出 #1

```
42
```

## 样例 #2

### 样例输入 #2

```
3 15
1 5 11
```

### 样例输出 #2

```
39
```

## 提示

对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le 10^3$，$1\le a_i \le  w\le 10^4$。  

其实小朋友并不有钱。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 10010;
const int mod = 10000000007;
int f[N], a[N];//f[i]表示凑够i的金额的总方案数

int main()
{
	int n, w;
    cin >> n >> w;
	for (int i = 1; i <= n; i++)
		cin >> a[i];

	
	f[0] = 1;
	for (int i = 1; i <= w; i++)
		for (int j = 1; j <= n; j++)
			if (i >= a[j]) f[i] = (f[i] + f[i - a[j]]) % mod;
	cout << f[w] << endl;
	return 0;

}
```

# [NOIP2006 提高组] 金明的预算方案

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

| 主件 | 附件 |
| :----------: | :----------: |
| 电脑 | 打印机，扫描仪 |
| 书柜 | 图书 |
| 书桌 | 台灯，文具 |
| 工作椅 | 无 |

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：

$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$。

请你帮助金明设计一个满足要求的购物单。

## 输入格式

第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。

第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$ 件物品的价格、重要度以及它对应的的主件。如果 $q_i=0$，表示该物品本身是主件。

## 输出格式

输出一行一个整数表示答案。

## 样例 #1

### 样例输入 #1

```
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```

### 样例输出 #1

```
2200
```

## 提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。
```cpp
#include<iostream>  
using namespace std;  
int m,n,mw[33333],mv[33333],fw[33333][3],fv[33333][3],f[33333],v,p,q;  
//mw主件重量，mv主件价值，fw主件对应的附件重量，fv主副价值，n总重量，m总个数   
int main()  
{  
    cin>>n>>m;  
    for(int i=1;i<=m;i++){  
    cin>>v>>p>>q;  
    if(!q){//如果是主件   
        mw[i]=v;//主件重量   
        mv[i]=v*p;//主件价值与重量乘积   
    }  
    else{//如果是附件   
        fw[q][0]++;//记录主件的附件个数（只记录在fw就行，fv那里没用   
        fw[q][fw[q][0]]=v;//主件的个数是用来确定该附件应该填在第一个还是第二个格子里   
        fv[q][fw[q][0]]=v*p;//（是第一个还是第二个附件）   
    }  
    }  
    for(int i=1;i<=m;i++)  
    for(int j=n;j>=mw[i];j--){//01背包模板   
    //每一个if的前提是背包能不能装下该物品   
        //情况1：只要主件 和啥都不要比较   
        f[j]=max(f[j],f[j-mw[i]]+mv[i]);  
        //情况2：主件和附件1 和上面选出的较大值比较   
        if(j>=mw[i]+fw[i][1])f[j]=max(f[j],f[j-mw[i]-fw[i][1]]+mv[i]+fv[i][1]);  
        //情况3：主件和附件2 和上面选出的较大值比较   
        if(j>=mw[i]+fw[i][2])f[j]=max(f[j],f[j-mw[i]-fw[i][2]]+mv[i]+fv[i][2]);  
        //情况4：都要   
        if(j>=mw[i]+fw[i][1]+fw[i][2])  
        f[j]=max(f[j],f[j-mw[i]-fw[i][1]-fw[i][2]]+mv[i]+fv[i][1]+fv[i][2]);  
    }  
    //输出在价值为n时能得到的最大值   
    cout<<f[n]<<endl;  
    return 0;  
}  

```