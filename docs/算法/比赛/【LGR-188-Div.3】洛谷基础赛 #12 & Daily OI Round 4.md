# 「Daily OI Round 4」Analysis

## 题目描述

小 C 的信息技术老师给小 C 布置了一项作业，作业内容如下：

> 有一个字符串，包含大小写字母和数字。你可以把任意一个字符变成另外一个字符，设变化之前字符的 ASCII 码为 $a$，变化之后字符的 ASCII 码为 $b$，则这次变化消耗 $|a-b|$ 的时间。你需要把整个字符串变成只包含大写字母的字符串。

小 C 还有语文数学英语等很多其他重要作业要做，为了节省时间，你需要计算小 C 最少需要多久才能令字符串只包含大写字母。

## 输入格式

一行一个字符串 $s$ 表示老师给的字符串。

## 输出格式

一行一个非负整数 $t$，表示令字符串只包含大写字母最少花费多少时间。

## 样例 #1

### 样例输入 #1

```
AA0aa
```

### 样例输出 #1

```
31
```

## 样例 #2

### 样例输入 #2

```
3kyOu
```

### 样例输出 #2

```
89
```

## 提示

#### 【样例解释】

对于第一组样例，最好的办法是变成 $\texttt{AAAZZ}$，这样的话消耗就为 $0+0+|48-65|+|97-90|+|97-90|=31$，容易证明不存在更优的解法。

其中 $48$ 是字符 $\texttt{0}$ 的 ASCII 码，$65$ 是字符 $\texttt{A}$ 的 ASCII 码，$90$ 是字符 $\texttt{Z}$ 的 ASCII 码，$97$ 是字符 $\texttt{a}$ 的 ASCII 码。

#### 【数据范围】

**本题开启捆绑测试。**

设 $len$ 为字符串 $s$ 的长度。

| $\text{Subtask}$ | 分值 | $len \le$ |
| :-----------: | :-----------: | :-----------: |
| $0$ | $10$ | $3$ |
| $1$ | $30$ | $10$ |
| $2$ | $60$ | $10^5$ |

对于全部数据，保证：$1 \le len \le 10^5$，且 $s$ 中只包含大小写字母和数字。


小写字母变成'A' 数字变成‘Z'

```cpp
#include <iostream>
#include <string>
#include <cctype> // 包含std::islower, std::isdigit等函数

int main() {
    std::string s;
    std::cin >> s;
    int time = 0;

    for (char &c : s) {
        if (std::islower(c)) {
            // 小写字母转换为大写A
            time += abs('Z' - c);
        } else if (std::isdigit(c)) {
            // 数字转换为大写
//            std::cout<<abs('A' - '0'-(c-'0') )<<std::endl;
            time += abs('A' - '0'-(c-'0') );
        }
        // 如果已经是大写字母，则不需要转换
    }

    std::cout << time << std::endl;
    return 0;
}
```
# 「Daily OI Round 4」Square

## 题目描述

小 A 给了你一个边长为 $n$ 的正方形网格，你需要把 $1 \sim n \times n$ 这些编号填入这个网格里面，满足每一行的编号加起来都是奇数，每一列的编号加起来都是偶数。

在填之前，你想知道是否有任何一种解法满足上述条件，如果可以，输出 `Yes`；否则，输出 `No`。

## 输入格式

一行一个正整数 $n$，表示正方形网格的边长。

## 输出格式

一行一个字符串，`Yes` 或 `No`。

## 样例 #1

### 样例输入 #1

```
2
```

### 样例输出 #1

```
Yes
```

## 样例 #2

### 样例输入 #2

```
755689
```

### 样例输出 #2

```
No
```

## 提示

#### 【样例解释】

对于第一组样例，设 $A$ 表示正方形网格，则有 $A_{1,1}=1,A_{1,2}=3,A_{2,1}=2,A_{2,2}=4$ 的解法。

对于第二组样例，可以证明无解。

#### 【数据范围】
  
**本题开启捆绑测试。**

|$\text{Subtask}$|分值|$n \le$|
| :-----------: | :-------------:|:-----------: |
|$0$|$10$|$10$|
|$1$|$20$|$10^6$|
|$2$|$70$|$10^{18}$|

对于全部数据，保证：$1 \le n \le 10^{18}$。

```cpp
#include<iostream>
using namespace std;
int main()
{
    long long n=0;
    cin>>n;
    if(n%2==0){
        cout<<"Yes"<<endl;
    }else{
        cout<<"No"<<endl;
    }
    return 0;

}
```



# 「Daily OI Round 4」Mine

## 题目描述

小 R 经营着一家矿场，这家矿场一共有 $n$ 种矿可以开采，开采区域可以看作一个数轴，第 $i$ 种矿可以在数轴上的 $[l_i,r_i]$ 这个区间内开采。

小 R 想要在铁匠铺锻造一些装备，但是铁匠给他所需要的矿石列表不小心弄丢了。他只知道，铁匠给他的矿石列表中的矿石都是这家矿场有的（列表中至少有一种矿石）。

这家矿场有 $m$ 个采矿点，第 $i$ 个采矿点在数轴上的坐标为 $a_i$。可怜的小 R 想要知道在所有可能的矿石列表中，有多少种使得存在一个采矿点满足他只在这个采矿点就能够采集到这个列表中的所有矿石。

## 输入格式

第一行两个整数 $n$ 和 $m$。

接下来 $n$ 行，每行两个整数 $l_i,r_i$，表示第 $i$ 种矿能被开采的区间。

然后 $m$ 行，每行一个整数 $a_i$，表示 $m$ 个采矿点的坐标。

## 输出格式

输出一行一个整数，表示满足条件的列表数量。答案可能很大，你只需要输出答案对 $998244353$ 取模后的结果。

## 样例 #1

### 样例输入 #1

```
3 2
7 11
1 5
3 8
4
7
```

### 样例输出 #1

```
5
```

## 提示

#### 【样例解释】

第一个样例有三种矿物，我们可以在采矿点 $1$ 采集到第 $2,3$ 种矿物，在采矿点 $2$ 采集到第 $1,3$ 种矿物，因此，满足条件的列表如下：

$$
[1],[2],[3],[1,3],[2,3]
$$

一共 $5$ 种列表。

#### 【数据范围】
  
**本题采用捆绑测试。**

|$\text{Subtask}$|分值|$n,m \le$|
| :-----------: | :-------------:|:-----------: |
|$0$|$20$|$20$|
|$1$|$20$|$1000$|
|$2$|$60$|$10^5$|

对于全部数据：$1\le n,m\le 10^5$，$1\le l_i \le r_i \le 10^5$，$1\le a_i \le 10^5$，保证 $a_i$ 两两不同。