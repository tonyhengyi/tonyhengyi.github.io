# 最长平台

## 题目描述

对于一个数组，其连续的相同段叫做一个平台，例如，在 $1$，$2$，$2$，$3$，$3$，$3$，$4$，$5$，$5$，$6$ 中 $1$，$2-2$，$3-3-3$，$4$，$5-5$，$6$ 都是平台。

编写一个程序，接收一个数组，找出最长的平台。在上面的例子中 $3-3-3$ 就是最长的平台。

## 输入格式

第一行有一个整数 $n$，为数组元素的个数。（$1 \le n \le 100$）

第二行有 $n$ 个整数，整数之间以一个空格分开，整数 $k$ 范围（$0<k<2000$）。

## 输出格式

输出最长平台的长度。

## 样例 #1

### 样例输入 #1

```
10
1 2 2 3 3 3 4 5 5 6
```

### 样例输出 #1

```
3
```

```cpp
#include<iostream>
using namespace std;
const int N=110;
int a[N];
int main()
{
    int n,ans=1,res;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<n;i++){
        if(a[i]==a[i+1])
        {
            ans++;
        }
        else{
            ans=1;
        }
        res=max(res,ans);
    }
    cout<<res<<endl;
}
```







# 同行列对角线的格

## 题目描述

输入三个自然数 $N$，$i$，$j$（$1 \le i \le n$，$1 \le j \le n$），输出在一个 $N \times N$ 格的棋盘中（行列均从 $1$ 开始编号），与格子 $(i$，$j)$ 同行、同列、同一对角线的所有格子的位置。

如：$n=4$，$i=2$，$j=3$ 表示了棋盘中的第二行第三列的格子，

当 $n=4$，$i=2$，$j=3$ 时，输出的结果是：

$(2,1)(2,2)(2,3)(2,4)$ 同一行上格子的位置。

$(1,3)(2,3)(3,3)(4,3)$ 同一列上格子的位置。

$(1,2)(2,3)(3,4)$ 左上到右下对角线上的格子的位置。

$(4,1)(3,2)(2,3)(1,4)$ 左下到右上对角线上的格子的位置。

## 输入格式

一行，三个自然数 $N$，$i$，$j$，相邻两个数之间用单个空格隔开 $(1 \le N \le 10)$。

## 输出格式

第一行：从左到右输出同一行格子位置；

第二行：从上到下输出同一列格子位置；

第三行：从左上到右下输出同一对角线格子位置；

第四行：从左下到右上输出同一对角线格子位置。

其中每个格子位置用如下格式输出：$(x,y)$，$x$ 为行号，$y$ 为列号，采用英文标点，中间无空格。相邻两个格子位置之间用单个空格隔开。

## 样例 #1

### 样例输入 #1

```
4 2 3
```

### 样例输出 #1

```
(2,1) (2,2) (2,3) (2,4)
(1,3) (2,3) (3,3) (4,3)
(1,2) (2,3) (3,4)
(4,1) (3,2) (2,3) (1,4)
```

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,x,y;
    cin>>n>>x>>y;
    for(int i=1;i<=n;i++){
        cout<<"("<<x<<","<<i<<")"<<" ";    	
    }
    cout<<endl;
    for(int i=1;i<=n;i++){
        cout<<"("<<i<<","<<y<<")"<<" ";    	
    }
    cout<<endl;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
		    if(i-j==x-y){
		        cout<<"("<<i<<","<<j<<")"<<" ";	
		    }
	    }
    }
    cout<<endl;
    for(int i=n;i>=1;i--){
        for(int j=1;j<=n;j++){
		    if(i+j==x+y){
		        cout<<"("<<i<<","<<j<<")"<<" ";	
		    }
	    }
    }
    cout<<endl;
	return 0;
}


```

```c






/************************************************
*原型：bit SubInFallControl(unsigned char cFmMotorOn,unsigned char cFmMotorOff,unsigned char cFmEndWaterLevel,unsigned char cFmInFallTime1S)
*功能：子进水过程控制
*说明：此进水程序包含两种运行模式：带电机运转和不带电机运转
*参数：电机运转参数，到达水位，和运算时间
*返回：过程完成标志
************************************************/
unsigned char SubInFallControl(unsigned char cFmMotorOn,unsigned char cFmMotorOff,unsigned char cFmEndWaterLevel,unsigned char cFmInFallTime1S)
{
    unsigned char cTemp=1;
//  unsigned char cInFallErrorCount;

//  static unsigned char cInitWaterLevel;//初始水位

    if(!bGoing)
    {
        bGoing=1;
        iTimer100msSub=0x0000;
        iTimer1secEnd=iTimer1secStep-cFmInFallTime1S;
        MotorInitial();
        iFactWaterLevelFrebak=0x0000;
        bInFallOvertime=0;
//      cInFallErrorCount=0x00;
    }
    else
    {
        cLoadOutReg.allBit=0x00;
        if(hFactWaterLevel<cFmEndWaterLevel)         //到达水位
        {
            bInValveReg=1;
            if(hFactWaterLevel<=WATERLEVEL_RES)//空桶
            {
                if(!bInFallOvertime)
                {
                    if(iTimer100msSub<=6000)//6000
                    {
                        iFactWaterLevelFrebak=iFactWaterLevelFre;
                        cInFallErrorCount=0x00;
                    }
                    else if((((iTimer100msSub-9000)-3000)<=10)&&(iTimer100msSub>=9000))
                    {
                        cInFallErrorCount++;
                        if(cInFallErrorCount<80)
                        {
//                          if((((iFactWaterLevelFrebak-iFactWaterLevelFre)<80)&&(iFactWaterLevelFrebak>iFactWaterLevelFre))||(iFactWaterLevelFrebak<iFactWaterLevelFre))
                            if((abs(iFactWaterLevelFrebak-iFactWaterLevelFre)<80)||(iFactWaterLevelFrebak<iFactWaterLevelFre))
                            {
                                bErrorInFall=1;
                                iTimer100msSub=0x0000;
                                bInFallOvertime=1;
                            }
                        }
                        else if(cInFallErrorCount<=90)
                        {
                            iFactWaterLevelFrebak=iFactWaterLevelFre;
                        }
                    }
                    else
                    {
                        cInFallErrorCount=0x00;
                    }
                }
                else
                {
                    if(iTimer100msSub<=10)
                    {
                        iFactWaterLevelFrebak=iFactWaterLevelFre;
                        cInFallErrorCount=0x00;
                    }
                    else if(((iTimer100msSub-3000)<=10)&&(iTimer100msSub>=3000))
                    {
                        cInFallErrorCount++;
                        if(cInFallErrorCount<80)
                        {
//                          if((((iFactWaterLevelFrebak-iFactWaterLevelFre)<80)&&(iFactWaterLevelFrebak>iFactWaterLevelFre))||(iFactWaterLevelFrebak<iFactWaterLevelFre))
                            if((abs(iFactWaterLevelFrebak-iFactWaterLevelFre)<80)||(iFactWaterLevelFrebak<iFactWaterLevelFre))
                            {
                                bErrorInFall=1;
                                iTimer100msSub=0x0000;
                                bInFallOvertime=1;
                            }
                        }
                        else if(cInFallErrorCount<=90)
                        {
                            iFactWaterLevelFrebak=iFactWaterLevelFre;
                        }
                    }
                    else
                    {
                        cInFallErrorCount=0x00;
                    }
                }
            }
            else//桶中有水
            {
                    if(iTimer100msSub<=10)
                    {
                        iFactWaterLevelFrebak=iFactWaterLevelFre;
                        cInFallErrorCount=0x00;
                    }
                    else if(((iTimer100msSub-3000)<=10)&&(iTimer100msSub>=3000))//3000
                    {
                        cInFallErrorCount++;
                        if(cInFallErrorCount<80)
                        {
//                          if((((iFactWaterLevelFrebak-iFactWaterLevelFre)<80)&&(iFactWaterLevelFrebak>iFactWaterLevelFre))||(iFactWaterLevelFrebak<iFactWaterLevelFre))
                            if((abs(iFactWaterLevelFrebak-iFactWaterLevelFre)<80)||(iFactWaterLevelFrebak<iFactWaterLevelFre))
                            {
                                bErrorInFall=1;
                                iTimer100msSub=0x0000;
                            }
                        }
                        else if(cInFallErrorCount<=90)
                        {
                            iFactWaterLevelFrebak=iFactWaterLevelFre;
                        }
                    }
                    else
                    {
                        cInFallErrorCount=0x00;
                    }
            }

            if(iTimer100msSub>=48000)   //进水超时80min报警 48000
            {
                bErrorInFall=1;
                iTimer100msSub=0x0000;
            }
        }
        else
        {
            bGoing=0;
            MotorInitial();
            iTimer1secStep=iTimer1secEnd;
            cTemp = 0;
            bInFallOvertime=0;
            cInFallErrorCount=0x00;
        }
    }
    return cTemp;
}

```