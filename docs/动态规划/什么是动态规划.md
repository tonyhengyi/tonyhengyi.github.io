## 纸笔问题


## 题目描述

某国有 $n$ 种纸币，每种纸币面额为 $a_i$ 并且有无限张，现在要凑出 $w$ 的金额，试问最少用多少张纸币可以凑出来？

## 输入格式

第一行两个整数 $n,w$，分别表示纸币的种数和要凑出的金额。  
第二行一行 $n$ 个以空格隔开的整数 $a_1, a_2, a_3, \dots a_n$ 依次表示这 $n$ 种纸币的面额。

## 输出格式

一行一个整数，表示最少使用的纸币张数。

## 样例 #1

### 样例输入 #1

```
6 15
1 5 10 20 50 100
```

### 样例输出 #1

```
2
```

## 样例 #2

### 样例输入 #2

```
3 15
1 5 11
```

### 样例输出 #2

```
3
```

## 提示

对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le 10^3$，$1\le a_i \leq w\le 10^4$。

宽搜解决的话，会比较繁琐

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int INF = 1e9;
int dfs(int w)
{
	if (w == 0) return 0;
	if (w < 0) return INF;
	return min(dfs(w - 1), min(dfs(w - 5), dfs(w - 11))) + 1;

}
int main()
{
	cout << dfs(15) << endl;
	return 0;
}

```

比起函数，dfs(w)的作用更加倾向于一个数组，里面的值在程序运行过程中是恒定的。在第一次运算到dsf(w)时候，将运算结果固定下来。存储到数组f的原色fw中。具体代码如下：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1e9;
int f[10010];

int dfs(int w) {
	if (w < 0) return N;
	if (f[w] != N) return f[w];
	if (w == 0) return 0;
	int x= min(dfs(w - 1), min(dfs(w - 5), dfs(w - 11))) + 1;
	f[w] = x;
	return f[w];
}
int main()
{
	int k = 15;
	for (int i = 1; i <= k; i++) f[i] = N;
	cout << dfs(k);
	return 0;
}
```

## 数字三角形


## 题目描述

观察下面的数字金字塔。


写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。

## 输入格式

第一个行一个正整数 $r$ ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。

## 输出格式

单独的一行,包含那个可能得到的最大的和。

## 样例 #1

### 样例输入 #1

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

### 样例输出 #1

```
30
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。


### 可以先考虑暴力搜索
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1010;
int a[N][N];
int n;
int dfs(int x, int y)
{
	if (x == n)	return a[x][y];
	return max(dfs(x + 1, y), dfs(x + 1, y + 1)) + a[x][y];
}
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= i; j++)
			cin >> a[i][j];
	cout << dfs(1, 1) << endl;
	return 0;
}
```

与之前那个题目的相似点在于，dfs(x,y)的值对于x,y来讲是固定的，从x走到y最大值只和下面的数字有关系一开始就是固定的，就可以也是用***数组***来求解

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1010;
int a[N][N], n;
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= i; j++)
			cin >> a[i][j];

	for (int i = n; i > 1; i--)
		for (int j = 1; j <= i - 1; j++)
			a[i - 1][j] += max(a[i][j], a[i][j + 1]);
	cout << a[1][1] << endl;
	return 0;
}
```

# [NOIP2002 普及组] 过河卒

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/f3wwgqj6.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

## 输入格式

一行四个正整数，分别表示 $B$ 点坐标和马的坐标。

## 输出格式

一个整数，表示所有的路径条数。

## 样例 #1

### 样例输入 #1

```
6 6 3 3
```

### 样例输出 #1

```
6
```

## 提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题

这道题初始位置是从 0 开始的，这样不是很利于我们解题，所以不如暂且把这题里涉及的坐标统统 +1，那么初始位置就从 (0,0)(0,0) 变成了 (1,1)(1,1)。

先考虑如果没有任何马的限制，卒子可以随便向右向下走，那么可以想到，一个卒子只能从 当前格子的左侧格子 和 当前格子的上方格子 上走到当前格子。那么假设从 (1,1)(1,1) 走到 当前格子的左侧格子 的路径条数是 �x，从 (1,1)(1,1) 走到 当前格子的上方格子 的路径条数是 �y，那么从 (1,1)(1,1) 走到当前格子的路径条数就应该是 �+�x+y。

其实我们已经得到了一个动态规划的转移方程，设 �(�,�)f(i,j) 表示从 (1,1)(1,1) 格子走到当前格子的路径条数，那么根据上一段得到的结论，可以得到：

�(�,�)=�(�−1,�)+�(�,�−1)f(i,j)=f(i−1,j)+f(i,j−1)

(�,�)(i,j) 是当前格子，那么 (�−1,�)(i−1,j) 就是 当前格子的上方格子，(�,�−1)(i,j−1) 就是 当前格子的左侧格子。我们只需要从小到大依次枚举 �i 和 �j 就能获得所有点的答案，可以想到，在这道题里我们要求的答案就是 �(�,�)f(n,m)（因为 B 点的坐标是(�,�)(n,m)）。

当然如果只是按照这个公式推肯定不行，因为 �f 的初始数值都是 0，再怎么推也都是 0，我们要让 �(1,1)f(1,1) 能根据上面得到的式子推出答案是 1，这样才能有有意义的结果。根据 �(1,1)=�(0,1)+�(1,0)f(1,1)=f(0,1)+f(1,0)，我们只需要让 �(1,0)=1f(1,0)=1 或者 �(0,1)=1f(0,1)=1 即可。

接下来考虑一下加入了 马 这道题该怎么做，假设 (�,�)(x,y) 这个点被马拦住了，其实就是说这个点不能被卒子走到，那当我们枚举到这个点的时候，发现他被马拦住了，那就直接跳过这个点，让 �(�,�)=0f(x,y)=0 就行了。

具体写代码的时候我们注意到在判断一个点有没有被马拦住时，会用到 (�−2,�−1)(i−2,j−1) 和 (�−1,�−2)(i−1,j−2) 这两个位置，那如果不把所有的点的坐标都加上 2 （前面分析的时候只把所有的坐标加上 1），就会因为数组越界而 WA 掉一个点。

答案可能很大，所以记得开 `long long`。

```cpp
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int fx[] = { 0,-2,-1,1,2,2,1,-1,-2 };
const int fy[] = { 0,1,2,2,1,-1,-2,-2,-1 };
int bx, by, mx, my;
ll f[40][40];
bool s[40][40];//判断这个点有没有被马拦住

int main()
{
	cin >> bx >> by >> mx >> my;
	bx += 2, by += 2, mx += 2, my += 2;//坐标都加上2，防止越界
	f[2][1] = 1;//初始化，仅仅递归式，全部是0推导的没有意义
	s[mx][my] = 1;//标记马的位置
	for (int i = 1; i <= 8; i++) s[mx + fx[i]][my + fy[i]] = 1;
	for (int i = 2; i <= bx; i++)
		for (int j = 2; j <= by; j++) {
			if (s[i][j]) continue;//被马拦住，剪枝丫
			f[i][j] = f[i - 1][j] + f[i][j - 1];
		}
	cout << f[bx][by] << endl;
	return 0;
}

```


# [NOIP2005 普及组] 采药

## 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”


如果你是辰辰，你能完成这个任务吗？

## 输入格式

第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le  M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。

接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。

## 输出格式

输出在规定的时间内可以采到的草药的最大总价值。

## 样例 #1

### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

### 样例输出 #1

```
3
```

## 提示

**【数据范围】**

- 对于 $30\%$ 的数据，$M \le 10$；
- 对于全部的数据，$M \le 100$。

**【题目来源】**

NOIP 2005 普及组第三题